.so fork.tmac
.SH EXAMPLE
.PP
The following example uses nearly every resource in the
library.  It omits only
.B argeater_dump_args
which is used for debugging.
.PP
.PP
Compile the following source code with:
.in 12
.EX
cc -o example test_example.c libargeater.a
.EE
.in
.sp
.EX
// file: test_example.c

\(shinclude <argeater.h>
\(shinclude <alloca.h>
\(shinclude <stddef.h>

\fB// declare variables for the action map:\fP
const char *help_flag = NULL;
const char *filename = NULL;
const char *verbose_flag = NULL;
const char *favcolor = NULL;

\fB// attach variables to actions:\fP
AE_ITEM actions[] = {
  { &help_flag,    \(dqhelp\(dq,     \(aqh\(aq,  AET_FLAG_OPTION },
  { &filename,     \(dqfilename\(dq, \(aq\(rs0\(aq, AET_ARGUMENT },
  { &verbose_flag, \(dqverbose\(dq,  \(aqv\(aq,  AET_FLAG_OPTION },
  { &favcolor,     \(dqfavcolor\(dq, \(aqc\(aq,  AET_VALUE_OPTION }
};

\fB// Use macro to intializa a AE_MAP instance:\fP
AE_MAP action_map = INIT_MAP(actions);

\fB// Use library functions to build a usage display:\fP
void show_help(AE_MAP *map, const char *cmdname)
{
   argeater_show_usage(map, cmdname);
   argeater_show_options(map, 3);
   argeater_show_arguments(map, 3);
}

int main(int argc, const char **argv)
{
   \fB// Collect arguments into a linked list:\fP
   ACLONE *clones = CLONE_ARGS(argc, argv);

   \fB// \(dqeat\(dq the arguments to set variables:\fP
   if (argeater_process(clones, &action_map))
   {
      \fB// Read mapped variables and respond according to plan\fP
      if (help_flag)
      {
         \fB// (First CL argument is command name:)\fP
         show_help(&action_map, *argv);
         return 1;
      }
      // else
      //   return run_program_reading_global_vars();
   }
   else
      fprintf(stderr, \(dqError processing arguments.\(rsn\(dq);

   return 0;
}
.EE
.SS ACTION_SETTER EXAMPLE
.PP
This topic is a little too complicated to include in the general
example.
It will set an integer value, validating the data-type and range
of the value before saving it to the target.
.PP
.EX
// The target variable (not a string):
int debug_level = 0;

// The custom setter function:
void set_debug_level(const char **target, const char *arg)
{
   char *end;
   int val = (int)strtol(&arg, &end, 10);
   if (end == arg)
      fprintf(stderr, \(dq\(aq%s\(aq is not a number.\(rsn\(dq, arg);
   else if (val<0 || val>3)
      fprintf(stderr, \(dq\(aq%d\(aq is not a valid debug level.\(rsn\(dq, val);
   else
   {
      *(int*)target = val;
      return;
   }

   exit(1);
}

// Actions array with AE_ITEM invoking the custom setter function:
AE_ITEM actions[] = {
  { (const char**)&debug_level,
   \(dqdeblev\(dq,
   \(aqd\(aq,
   AET_VALUE_OPTION,
   \(dqSet the debug level\(dq,
   \(dqdebug level\(dq,
   set_debug_level }
};

AE_MAP action_map = INIT_MAP(actions);
.EE
.PP
With these things set up, running
.B argeater_process
will use the custom
.B action_setter
function to process a
.I debug level
option.
